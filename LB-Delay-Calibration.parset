##################################################################
## LOFAR long baseline calibration pipeline parset              ##
##  - This pipeline requires prefactor V3                       ##
##    to have already been run on both calibrator               ##
##    and target.                                               ##
##  - The working and runtime directory are expected            ##
##    to be the same.                                           ##
##  - Please report any issues at                               ##
##    https://github.com/lmorabit/long_baseline_pipeline        ##
##################################################################


##########################################################
## Please update these parameters.                      ##
##########################################################

# software paths
! long_baseline_pipeline_dir            = /home/lmorabit/long_baseline_pipeline_new
! prefactor_dir                         = /home/lmorabit/prefactor
! losoto_directory                      = /home/lmorabit/losoto
! aoflagger                             = /opt/cep/aoflagger/aoflagger-2.14.0/build/bin/aoflagger ## path to your aoflagger executable
! lofar_directory                       = $LOFARROOT

# ## target data information
! target_input_path             = /data/scratch/lb_bw/targetdata
! target_input_pattern          = L*.MS

## Prefactor solution information
! prefac_tgt_dir	= input.output.job_directory/../Pre-Facet-Target
! cal_solutions         = {{ prefac_tgt_dir }}/results/cal_values/solutions.h5  ## location of h5parm from prefactor - should contain 'calibrator' and 'target' information
! solutions             = input.output.job_directory/solutions.h5
! phasesol              = TGSSphase

## Stations to flag
! flag_baselines        = [ ] ## for HBA data before October 2015, should set to: [ CS013HBA* ]

## averaging information -- do not touch unless you know what you are doing!
! cal_shift_avg_freqstep    = 8
! cal_shift_avg_timestep    = 8

###########################################################
### DDF Options -- please check even if not using        ##
###########################################################

! substep_ddf             = # ,apply_ddf   ## set to apply_ddf to use, leave blank otherwise
! ddf_soldir              = # /data/scratch/lb_bw/targetddf/L602888/SOLSDIR     ## path to 'SOLSDIR' from ddf-pipeline run, leave blank otherwise
! delaycal_col            = DATA ## set to DATA_DI_CORRECTED if applying ddf solutions, DATA otherwise.

##########################################################
## These parameters may need to be updated.        ##
##########################################################

## Station combination
! phaseup_command               = {ST001:'CS*'} ## 'CS*' for all core stations (or select stations you want to use)
! filter_command = '!CS*&&*' ## remove the core stations after combination

## Output directories
! job_directory                 = input.output.job_directory ## directory of the prefactor outputs
! results_directory             = {{ job_directory }}/results
! inspection_directory          = {{ results_directory }}/inspection/
! cal_values_directory          = {{ results_directory }}/calibrator_results/

## catalogue information
! lotss_skymodel         = {{ job_directory }}/lotss_catalogue.csv
! lbcs_skymodel          = {{ job_directory }}/lbcs_catalogue.csv
! image_cat              = {{ job_directory }}/image_catalogue.csv
! delay_cat              = {{ job_directory }}/delay_calibrators.csv
! subtract_cat           = {{ job_directory }}/subtract_sources.csv
! continue_without_lotss = True

## setup for running steps
! substep_clip     = clipATeam,     ## leave blank for no a-team clipping
! substep_flag     = # aoflagging,    ## aoflagging,  ## turned off by default
! substep_delay    = # ,delaycal    ## off by default, turn on to do a single in-field delay calibration
! substep_apply    = # ,applydelay ## off by default, turn on ONLY IF you have run substep_delay and wish to apply solutions

##########################################################
## Changing these will probably break something.    ##
##########################################################

## global information
! base_directory          = input.output.working_directory  
! job_directory           = input.output.job_directory      
! scripts                 = {{ long_baseline_pipeline_dir }}/bin
! prefactor_scripts       = {{ prefactor_dir }}/scripts

## parameters for pipeline performance
! rfistrategy                       = HBAdefault
! min_length                        =  5          ## minimum amount of chunks to concatenate in frequency necessary to perform the wide-band flagging in the RAM. It data is too big aoflag will use indirect-read.
! overhead                          =  0.5        ## Only use this fraction of the available memory for deriving the amount of data to be concatenated.
! min_separation                    =  30         ## minimal accepted distance to an A-team source on the sky in degrees (will raise a WARNING)
## Runtime setup -- will depend on your computing cluster
! num_proc_per_node                 = input.output.max_per_node    ## number of processes to use per step per node
! num_proc_per_node_limit           = 4     ## number of processes to use per step per node for tasks with high i/o (dppp or cp) or memory (eg calibration)
! max_dppp_threads                  = 2     ## number of threads per process for NDPPP
! error_tolerance                   = False ## False = stop if any subband fails, True = keep going

##
## END CONFIGURATION


##########################################################
## Steps to run.                                        ##
##########################################################

pipeline.steps = [ setup, prep, {{ substep_clip }} {{ substep_flag }} concat {{ substep_ddf }} {{ substep_delay }} {{ substep_apply }} ]

pipeline.steps.setup = [ mk_results_dir, mk_inspect_dir, mk_cal_values_dir, createmap_target, createmap_target_list, cp_cal_solutions, download_cats ]
pipeline.steps.prep = [ ndppp_prep_target, ndppp_prep_target_list ]
pipeline.steps.clipATeam   =  [ create_ateam_model_map, make_sourcedb_ateam, expand_sourcedb_ateam, predict_ateam, ateamcliptar]
pipeline.steps.aoflagging = [ ms_concat_target, ms_concat_target_map, aoflag ]
pipeline.steps.concat = [ sort_concatmap, do_sortmap_maps, dpppconcat, dpppconcat_list ]
pipeline.steps.apply_ddf = [ createmap_ddf, ddf_solutions, ddf_h5parms, convert_to_h5, expand_concat_map, addIS, h5imp_ddf_map, h5imp_ddf, ndppp_applycal ]
pipeline.steps.delaycal = [ do_parallel, find_delay_cal, prep_dirs, dppp_phaseup, delay_cal_model, delay_cal_model_map, delay_cal_parmmap, calib_cal, delaysol_map, h5_imp_delaysol_map, make_losoto, process_losoto, copy_h5imp_cal ]
pipeline.steps.applydelay = [ copyST_gains, expand_h5_map, ndppp_apply_delay ]



##################################################################################################################
##                                                                                                              ##
##            BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!                                                    ##
##                                                                                                              ##
##################################################################################################################

#######################################
## SETUP

# create the results directory if needed
mk_results_dir.control.kind               = plugin
mk_results_dir.control.type               = makeDirectory
mk_results_dir.control.directory          = {{ results_directory }}

# create the inspection_directory if needed
mk_inspect_dir.control.kind               = plugin
mk_inspect_dir.control.type               = makeDirectory
mk_inspect_dir.control.directory          = {{ inspection_directory }}

# create the cal_values_directory if needed
mk_cal_values_dir.control.kind            =  plugin
mk_cal_values_dir.control.type            =  makeDirectory
mk_cal_values_dir.control.directory       =  {{ cal_values_directory }}

# generate a mapfile of all the target data
createmap_target.control.kind             = plugin
createmap_target.control.type             = makeTargetmap
createmap_target.control.method           = mapfile_from_folder
createmap_target.control.mapfile_dir      = input.output.mapfile_dir
createmap_target.control.filename         = createmap_target.mapfile
createmap_target.control.folder           = {{ target_input_path }}
createmap_target.control.pattern          = {{ target_input_pattern }}
createmap_target.control.ddf_solsdir      = {{ ddf_soldir }}
createmap_target.control.prefacet_dir     = {{ prefac_tgt_dir }}

# convert to a mapfile with all subbands in one list
createmap_target_list.control.kind            =   plugin
createmap_target_list.control.type            =   createMapfile
createmap_target_list.control.method          =   mapfile_all_to_one
createmap_target_list.control.mapfile_dir     =   input.output.mapfile_dir
createmap_target_list.control.filename        =   combine_data_tar_map.mapfile
createmap_target_list.control.mapfile_in      =   createmap_target.output.mapfile

# copy the cal solutions to operate on
cp_cal_solutions.control.kind                 = recipe
cp_cal_solutions.control.type                 = executable_args
cp_cal_solutions.control.executable           = /bin/cp
cp_cal_solutions.control.max_per_node         = 1
cp_cal_solutions.control.skip_infile          = True
cp_cal_solutions.control.mapfile_in           = createmap_target_list.output.mapfile
cp_cal_solutions.argument.flags               = [{{ cal_solutions }}, {{ solutions }}]

# download the relevant catalogues
download_cats.control.kind                    = plugin
download_cats.control.type                    = DownloadCats
download_cats.control.mapfile_in              = createmap_target_list.output.mapfile
download_cats.control.lotss_radius            = 2.
download_cats.control.lbcs_radius             = 2.
download_cats.control.bright_limit_Jy         = 5.
download_cats.control.lotss_catalogue         = {{ lotss_skymodel }}
download_cats.control.lbcs_catalogue          = {{ lbcs_skymodel }}
download_cats.control.lotss_result_file       = {{ image_cat }}
download_cats.control.delay_cals_file         = {{ delay_cat }}
download_cats.control.subtract_file           = {{ subtract_cat }}
download_cats.control.match_tolerance         = 5.
download_cats.control.subtract_limit          = 0.5
download_cats.control.image_limit_Jy          = 0.05
download_cats.control.continue_no_lotss       = {{ continue_without_lotss }}
       

# run NDPPP on the target data to flag and apply solutions
ndppp_prep_target.control.type                          = dppp
ndppp_prep_target.control.max_per_node                  = {{ num_proc_per_node }}
ndppp_prep_target.control.error_tolerance               = {{ error_tolerance }}
ndppp_prep_target.argument.numthreads                   = {{ max_dppp_threads }}
ndppp_prep_target.argument.msin                         = createmap_target.output.mapfile  
ndppp_prep_target.argument.msin.datacolumn              = DATA
ndppp_prep_target.argument.msin.baseline                = *&
ndppp_prep_target.argument.msout.datacolumn             = DATA
ndppp_prep_target.argument.msout.storagemanager         = dysco
ndppp_prep_target.argument.msout.writefullresflag       = False
ndppp_prep_target.argument.msout                        = .
ndppp_prep_target.argument.steps                        = [flag,flagamp,filter,applyPA,applybandpass,applyclock,applyRM,applybeam,applyphase,count]
ndppp_prep_target.argument.flag.type                    = preflagger
ndppp_prep_target.argument.flag.baseline                = {{ flag_baselines }}
ndppp_prep_target.argument.flagamp.type                 = preflagger
ndppp_prep_target.argument.flagamp.amplmin              = 1e-30
ndppp_prep_target.argument.filter.type                  = filter
ndppp_prep_target.argument.filter.baseline              = {{ filter_baselines }}
ndppp_prep_target.argument.filter.remove                = true
ndppp_prep_target.argument.applyclock.type              = applycal
ndppp_prep_target.argument.applyclock.parmdb            = {{ solutions }}
ndppp_prep_target.argument.applyclock.correction        = clock
ndppp_prep_target.argument.applyclock.solset            = calibrator
ndppp_prep_target.argument.applyPA.type                 = applycal
ndppp_prep_target.argument.applyPA.parmdb               = {{ solutions }}
ndppp_prep_target.argument.applyPA.correction           = polalign
ndppp_prep_target.argument.applyPA.solset               = calibrator
ndppp_prep_target.argument.applybandpass.type           = applycal
ndppp_prep_target.argument.applybandpass.parmdb         = {{ solutions }}
ndppp_prep_target.argument.applybandpass.correction     = bandpass
ndppp_prep_target.argument.applybandpass.updateweights  = True
ndppp_prep_target.argument.applybandpass.solset         = calibrator
ndppp_prep_target.argument.applybeam.type               = applybeam
ndppp_prep_target.argument.applybeam.usechannelfreq     = True
ndppp_prep_target.argument.applybeam.updateweights      = True
ndppp_prep_target.argument.applyRM.type                 = applycal
ndppp_prep_target.argument.applyRM.parmdb               = {{ solutions }}
ndppp_prep_target.argument.applyRM.correction           = RMextract
ndppp_prep_target.argument.applyRM.solset               = target
ndppp_prep_target.argument.applyphase.type              = applycal
ndppp_prep_target.argument.applyphase.parmdb            = {{ solutions }}
ndppp_prep_target.argument.applyphase.correction        = {{ phasesol }}
ndppp_prep_target.argument.applyphase.solset            = target

# combine all entries into one mapfile
ndppp_prep_target_list.control.kind                                =   plugin
ndppp_prep_target_list.control.type                                =   createMapfile
ndppp_prep_target_list.control.method                              =   mapfile_all_to_one
ndppp_prep_target_list.control.mapfile_dir                         =   input.output.mapfile_dir
ndppp_prep_target_list.control.filename                            =   ndppp_prep_target_list.mapfile
ndppp_prep_target_list.control.mapfile_in                          =   ndppp_prep_target.output.mapfile

##################################################################
#                                                               ##
#                     CLIP THE A-TEAM                           ##
#                                                               ##
##################################################################

# create a mapfile with the A-Team skymodel, length = 1
create_ateam_model_map.control.kind                            =   plugin
create_ateam_model_map.control.type                            =   addListMapfile
create_ateam_model_map.control.hosts                           =   ['localhost']
create_ateam_model_map.control.files                           =   [ {{ prefactor_dir }}/skymodels/Ateam_LBA_CC.skymodel ]
create_ateam_model_map.control.mapfile_dir                     =   input.output.mapfile_dir
create_ateam_model_map.control.filename                        =   ateam_model_name.mapfile

# make sourcedbs from the A-Team skymodel, length = 1
make_sourcedb_ateam.control.kind                               =   recipe
make_sourcedb_ateam.control.type                               =   executable_args
make_sourcedb_ateam.control.executable                         =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb_ateam.control.error_tolerance                    =   {{ error_tolerance }}
make_sourcedb_ateam.control.args_format                        =   lofar
make_sourcedb_ateam.control.outputkey                          =   out
make_sourcedb_ateam.control.mapfile_in                         =   create_ateam_model_map.output.mapfile
make_sourcedb_ateam.control.inputkey                           =   in
make_sourcedb_ateam.argument.format                            =   <
make_sourcedb_ateam.argument.outtype                           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_ateam.control.kind                             =   plugin
expand_sourcedb_ateam.control.type                             =   expandMapfile
expand_sourcedb_ateam.control.mapfile_in                       =   make_sourcedb_ateam.output.mapfile
expand_sourcedb_ateam.control.mapfile_to_match                 =   ndppp_prep_target.output.mapfile
expand_sourcedb_ateam.control.mapfile_dir                      =   input.output.mapfile_dir
expand_sourcedb_ateam.control.filename                         =   expand_sourcedb_ateam.datamap

# Predict, corrupt, and predict the ateam-resolution model, length = nfiles
predict_ateam.control.type                                     =   dppp
predict_ateam.control.mapfiles_in                              =   [ndppp_prep_target.output.mapfile,expand_sourcedb_ateam.output.mapfile]
predict_ateam.control.inputkeys                                =   [msin,sourcedb]
predict_ateam.control.inplace                                  =   True
predict_ateam.control.max_per_node                             =   {{ num_proc_per_node_limit }}
predict_ateam.control.error_tolerance                          =   {{ error_tolerance }}
predict_ateam.argument.numthreads                              =   {{ max_dppp_threads }}
predict_ateam.argument.msin.datacolumn                         =   DATA
predict_ateam.argument.msout.datacolumn                        =   MODEL_DATA
predict_ateam.argument.msout.storagemanager                    =   dysco
predict_ateam.argument.steps                                   =   [filter,predict]
predict_ateam.argument.filter.type                   =   filter
predict_ateam.argument.filter.baseline                   =   [CR]S*&
predict_ateam.argument.filter.remove                   =   False
predict_ateam.argument.predict.type                            =   predict
predict_ateam.argument.predict.operation                       =   replace
predict_ateam.argument.predict.sourcedb                        =   sourcedb
predict_ateam.argument.predict.sources                         =   [VirA_4_patch,CygAGG,CasA_4_patch,TauAGG]
predict_ateam.argument.predict.usebeammodel                    =   True
predict_ateam.argument.predict.usechannelfreq                  =   false
predict_ateam.argument.predict.onebeamperpatch                 =   True

# run the a-team clipper to flag data affected by the a-team
ateamcliptar.control.kind                                      =   recipe
ateamcliptar.control.type                                      =   executable_args
ateamcliptar.control.max_per_node                              =   {{ num_proc_per_node_limit }}
ateamcliptar.control.executable                                =   {{ prefactor_scripts }}/Ateamclipper.py
ateamcliptar.control.error_tolerance                           =   {{ error_tolerance }}
ateamcliptar.control.mapfile_in                                =   ndppp_prep_target.output.mapfile
ateamcliptar.control.arguments                                 =   [allms]
ateamcliptar.control.inputkey                                  =   allms


##################################################################
#                                                               ##
#                     AOFLAGGING                            ##
#                                                               ##
##################################################################

# virtually concatenate target subbands
ms_concat_target.control.type                                  =   pythonplugin
ms_concat_target.control.executable                            =   {{ prefactor_scripts }}/concat_MS.py
ms_concat_target.control.error_tolerance                       =   {{ error_tolerance }}
ms_concat_target.argument.filename                             =   concatmapfile.mapfile
ms_concat_target.argument.mapfile_dir                          =   input.output.mapfile_dir
ms_concat_target.argument.min_length                   =   {{ min_length }}
ms_concat.target.argument.overhead                   =   {{ overhead }}
ms_concat_target.argument.flags                                =   [ndppp_prep_target_list.output.mapfile,outputkey]

# convert the output of ms_concat_target into usable mapfiles
ms_concat_target_map.control.kind                              =   plugin
ms_concat_target_map.control.type                              =   mapfilenamesFromMapfiles
ms_concat_target_map.control.mapfile_concatmap                 =   ms_concat_target.output.concatmapfile.mapfile

# run aoflagger on the concatenated data
aoflag.control.kind                                            =   recipe
aoflag.control.type                                            =   executable_args
aoflag.control.inplace                                         =   True
aoflag.control.executable                                      =   {{ aoflagger }}
aoflag.control.max_per_node                                    =   1
aoflag.control.error_tolerance                                 =   {{ error_tolerance }}
aoflag.control.mapfile_in                                      =   ms_concat_target_map.output.concatmap
aoflag.control.inputkey                                        =   msin
aoflag.control.args_format                                     =   wsclean
aoflag.argument.strategy                                       =   {{ lofar_directory }}/share/rfistrategies/{{ rfistrategy }}
aoflag.argument.flags                                          =   [-v,-combine-spws,msin]

##################################################################
#                                                               ##
#                    CONCATENATION                        ##
#                                                               ##
##################################################################

# sort them by frequency and fill in missing subband information
sort_concatmap.control.type               = pythonplugin
sort_concatmap.control.executable         = {{ prefactor_scripts }}/sort_times_into_freqGroups.py
sort_concatmap.argument.flags             = [ndppp_prep_target_list.output.mapfile]
sort_concatmap.argument.filename          = sort_concatmap
sort_concatmap.argument.mapfile_dir       = input.output.mapfile_dir
sort_concatmap.argument.target_path       = {{ job_directory }}
sort_concatmap.argument.numSB             = 10
sort_concatmap.argument.NDPPPfill         = True
sort_concatmap.argument.stepname          = dpppconcat
sort_concatmap.argument.firstSB           = None
sort_concatmap.argument.truncateLastSBs   = False

# convert the output of sort_concatmap into usable mapfile
do_sortmap_maps.control.kind              =  plugin
do_sortmap_maps.control.type              =  mapfilenamesFromMapfiles
do_sortmap_maps.control.mapfile_groupmap  =  sort_concatmap.output.groupmapfile.mapfile
do_sortmap_maps.control.mapfile_datamap   =  sort_concatmap.output.mapfile.mapfile

# concatenate into bands into a single measurement set
dpppconcat.control.type                  = dppp
dpppconcat.control.max_per_node          = {{ num_proc_per_node_limit }}
dpppconcat.control.error_tolerance       = {{ error_tolerance }}
dpppconcat.control.mapfile_out           = do_sortmap_maps.output.groupmap
dpppconcat.control.mapfiles_in           = [do_sortmap_maps.output.datamap]
dpppconcat.control.inputkey              = msin
dpppconcat.argument.msin.datacolumn      = DATA
dpppconcat.argument.msin.missingdata     = True
dpppconcat.argument.msin.orderms         = False
dpppconcat.argument.msout.datacolumn     = DATA
dpppconcat.argument.msout.writefullresflag = False
dpppconcat.argument.msout.storagemanager = dysco
dpppconcat.argument.msout.overwrite      = True
dpppconcat.argument.steps                = [count]
dpppconcat.argument.numthreads           = {{ max_dppp_threads }}

# make a mapfile with all blocks in one list
dpppconcat_list.control.kind              = plugin
dpppconcat_list.control.type            =   createMapfile
dpppconcat_list.control.method          =   mapfile_all_to_one
dpppconcat_list.control.mapfile_dir     =   input.output.mapfile_dir
dpppconcat_list.control.filename        =  dpppconcat_list.mapfile
dpppconcat_list.control.mapfile_in      =  dpppconcat.output.mapfile

###################################################################
##                                                               ##
##            OPTIONAL -- APPLY DDF SOLUTIONS                    ##
##                                                               ##
###################################################################

# find the ddf solutions
createmap_ddf.control.kind             = plugin
createmap_ddf.control.type             = createMapfile
createmap_ddf.control.method           = mapfile_from_folder
createmap_ddf.control.mapfile_dir      = input.output.mapfile_dir
createmap_ddf.control.filename         = createmap_ddf.mapfile
createmap_ddf.control.folder           = {{ ddf_soldir }}
createmap_ddf.control.pattern          = L*pre-cal.ms

# get mapfile of npz
ddf_solutions.control.kind               =  plugin
ddf_solutions.control.type               =  createMapfile
ddf_solutions.control.method             =  add_suffix_to_file
ddf_solutions.control.mapfile_in         =  createmap_ddf.output.mapfile
ddf_solutions.control.add_suffix_to_file =  /killMS.DIS2_full.sols.npz
ddf_solutions.control.mapfile_dir        =  input.output.mapfile_dir
ddf_solutions.control.filename          =  ddf_solutions.mapfile

# make mapfile for output h5parms
ddf_h5parms.control.kind        = plugin
ddf_h5parms.control.type        = makeResultsMapfile
ddf_h5parms.control.mapfile_dir        = input.output.mapfile_dir
ddf_h5parms.control.filename        = ddf_h5parms.mapfile
ddf_h5parms.control.mapfile_in        = createmap_ddf.output.mapfile
ddf_h5parms.control.target_dir        = {{ job_directory }}
ddf_h5parms.control.new_suffix        = _ddf.h5

# run losoto to convert
convert_to_h5.control.kind            = recipe
convert_to_h5.control.type            = executable_args
convert_to_h5.control.executable        = {{ losoto_directory }}/bin/killMS2H5parm.py
convert_to_h5.control.max_per_node        = {{ num_proc_per_node }}
convert_to_h5.control.mapfiles_in        = [ddf_h5parms.output.mapfile,ddf_solutions.output.mapfile]
convert_to_h5.control.inputkeys            = [outputh5,inputnpz]
convert_to_h5.argument.flags            = [outputh5,inputnpz]

expand_concat_map.control.kind                      = plugin
expand_concat_map.control.type                      = expandMapfile
expand_concat_map.control.mapfile_in                = dpppconcat.output.mapfile
expand_concat_map.control.mapfile_to_match          = ddf_h5parms.output.mapfile
expand_concat_map.control.mapfile_dir               = input.output.mapfile_dir
expand_concat_map.control.filename                  = expand_concat_map.mapfile

# add the international stations
# addIS.control.kind                = recipe
addIS.control.type                = pythonplugin
addIS.control.executable            = {{ long_baseline_pipeline_dir }}/bin/addIS_to_h5.py
addIS.control.max_per_node            = {{ num_proc_per_node }}
addIS.control.mapfiles_in            = [expand_concat_map.output.mapfile,ddf_h5parms.output.mapfile]
addIS.control.inputkeys                = [msin,h5parms]
addIS.argument.solset_in            = sol000
addIS.argument.solset_out            = sol001
addIS.argument.do_int_stations            = True
addIS.argument.flags                = [h5parms,msin]

# generate a mapfile with all files in a single entry
h5imp_ddf_map.control.kind              =   plugin
h5imp_ddf_map.control.type              =   compressMapfile
h5imp_ddf_map.control.mapfile_in        =   ddf_h5parms.output.mapfile
h5imp_ddf_map.control.mapfile_dir       =   input.output.mapfile_dir
h5imp_ddf_map.control.filename          =   h5imp_ddf_map

# collect all instrument tables into one h5parm
h5imp_ddf.control.kind                  =   recipe
h5imp_ddf.control.type                  =   executable_args
h5imp_ddf.control.executable            =   {{ losoto_directory }}/bin/H5parm_collector.py
h5imp_ddf.control.error_tolerance       =   {{ error_tolerance }}
h5imp_ddf.control.mapfile_in            =   h5imp_ddf_map.output.mapfile
h5imp_ddf.control.inputkey              =   h5parm
h5imp_ddf.argument.flags                =   [-v,-c,h5parm]
h5imp_ddf.argument.outh5parm            =   {{ job_directory }}/ddf_solutions.h5
h5imp_ddf.argument.insolset             =   sol001

# apply the solutions
ndppp_applycal.control.type                    = dppp
ndppp_applycal.control.max_per_node            = {{ num_proc_per_node }}
ndppp_applycal.control.error_tolerance         = {{ error_tolerance }}
ndppp_applycal.control.mapfile_in              = dpppconcat.output.mapfile
ndppp_applycal.control.inputkey                = msfiles
ndppp_applycal.control.inplace            = True
ndppp_applycal.argument.numthreads             = {{ max_dppp_threads }}
ndppp_applycal.argument.msin                   = msfiles
ndppp_applycal.argument.msin.datacolumn        = DATA
ndppp_applycal.argument.msin.baseline          = *&
ndppp_applycal.argument.msout.datacolumn       = {{ delaycal_col }}
ndppp_applycal.argument.msout.writefullresflag = False
ndppp_applycal.argument.msout.storagemanager   = dysco
ndppp_applycal.argument.steps                  = [applyddf]
ndppp_applycal.argument.applyddf.type           = applycal
ndppp_applycal.argument.applyddf.parmdb         = {{ job_directory }}/ddf_solutions.h5
ndppp_applycal.argument.applyddf.correction     = fulljones
ndppp_applycal.argument.applyddf.solset         = sol000
ndppp_applycal.argument.applyddf.soltab         = [amplitude000,phase000]

###################################################################
##                                                               ##
##                       DELAY CALIBRATION                       ##
##                                                               ##
###################################################################

# do a parallel search for the best delay calibrator
do_parallel.control.type                  = pythonplugin
do_parallel.control.max_per_node          = {{ num_proc_per_node }}
do_parallel.control.executable            = {{ scripts }}/evaluate_potential_delay_calibrators.py
do_parallel.argument.flags                = [dpppconcat_list.output.mapfile,{{ delay_cat }}]
do_parallel.argument.ncpu                 = {{ num_proc_per_node }}
do_parallel.argument.datacol          = {{ delaycal_col }}
do_parallel.argument.nsbs          = 2

# automatically find the best calibrator 
find_delay_cal.control.kind               = plugin
find_delay_cal.control.type               = DelayCalToMapfile
find_delay_cal.control.delaycals          = {{ delay_cat }}
find_delay_cal.control.clphase_file       = {{ job_directory }}/closure_phases.txt

# Initialise file with direction of delay calibrator
prep_dirs.control.kind                    = plugin
prep_dirs.control.type                    = TargetListToMapfile
prep_dirs.control.mapfile_dir             = input.output.mapfile_dir
prep_dirs.control.infile                  = dpppconcat.output.mapfile
prep_dirs.control.filename                = prep_dirs.mapfile
prep_dirs.control.wd                      = {{ job_directory }}
prep_dirs.control.nP                      = 3   # this is the default setting
prep_dirs.control.counter                 = 0
prep_dirs.control.manual                  = True ## 
prep_dirs.control.target_file             = find_delay_cal.output.calfile

# shift, average and add up stations for tied array
dppp_phaseup.control.type                 = dppp
dppp_phaseup.control.max_per_node         = {{ num_proc_per_node }}
dppp_phaseup.control.mapfile_out          = prep_dirs.output.mapfile
dppp_phaseup.argument.msin                = dpppconcat.output.mapfile
dppp_phaseup.argument.msin.datacolumn     = {{ delaycal_col }}
dppp_phaseup.argument.msout.datacolumn    = DATA
dppp_phaseup.argument.msout.storagemanager= dysco
dppp_phaseup.argument.msout.overwrite     = True
dppp_phaseup.argument.steps               = [shift, avg, adder, filter]
dppp_phaseup.argument.shift.type          = phaseshift
dppp_phaseup.argument.shift.phasecenter   = prep_dirs.output.coords
dppp_phaseup.argument.avg.type            = squash
dppp_phaseup.argument.avg.freqstep        = {{ cal_shift_avg_freqstep }}
dppp_phaseup.argument.avg.timestep        = {{ cal_shift_avg_timestep }}
dppp_phaseup.argument.adder.type          = stationadder
dppp_phaseup.argument.adder.stations      = {{ phaseup_command }}
dppp_phaseup.argument.filter.type         = filter
dppp_phaseup.argument.filter.baseline     = {{ filter_command }}
dppp_phaseup.argument.filter.remove       = True
dppp_phaseup.argument.numthreads          = {{ max_dppp_threads }}

# generate the calibrator model with skynet
delay_cal_model.control.type                  = pythonplugin
delay_cal_model.control.executable            = {{ scripts }}/skynet.py
delay_cal_model.control.mapfile_in            = dppp_phaseup.output.mapfile
delay_cal_model.control.inputkey              = msin
delay_cal_model.argument.flags                = [msin]
delay_cal_model.argument.delayCalFile         = {{ delay_cat }}

# generate mapfile with the sourceDB names to be used in the gsmcal steps
delay_cal_model_map.control.kind               =  plugin
delay_cal_model_map.control.type               =  createMapfile
delay_cal_model_map.control.method             =  add_suffix_to_file
delay_cal_model_map.control.mapfile_in         =  dppp_phaseup.output.mapfile
delay_cal_model_map.control.add_suffix_to_file =  /sky
delay_cal_model_map.control.mapfile_dir        =  input.output.mapfile_dir
delay_cal_model_map.control.filename           =  delay_cal_model_map.mapfile

# generate mapfile of parmdb names
delay_cal_parmmap.control.kind               =  plugin
delay_cal_parmmap.control.type               =  createMapfile
delay_cal_parmmap.control.method             =  add_suffix_to_file
delay_cal_parmmap.control.mapfile_in         =  dppp_phaseup.output.mapfile
delay_cal_parmmap.control.add_suffix_to_file =  _delay_instrument.h5
delay_cal_parmmap.control.mapfile_dir        =  input.output.mapfile_dir
delay_cal_parmmap.control.filename           =  delay_cal_parmdbs.mapfile

# generate gain solutions
calib_cal.control.type                    = dppp
calib_cal.control.inplace                 = True
calib_cal.control.max_per_node            = {{ num_proc_per_node_limit }}
calib_cal.control.error_tolerance         = {{ error_tolerance }}
calib_cal.control.mapfiles_in             = [dppp_phaseup.output.mapfile, delay_cal_model_map.output.mapfile, delay_cal_parmmap.output.mapfile]
calib_cal.control.inputkeys               = [msin, gaincal.sourcedb, gaincal.parmdb]
calib_cal.argument.numthreads             = {{ max_dppp_threads }}
calib_cal.argument.msin.datacolumn        = DATA
calib_cal.argument.steps                  = [gaincal]
calib_cal.argument.gaincal.type           = gaincal
calib_cal.argument.gaincal.caltype        = diagonal
calib_cal.argument.gaincal.applysolution  = False
calib_cal.argument.gaincal.nchan          = 1
calib_cal.argument.gaincal.solint         = 1
calib_cal.argument.gaincal.usebeammodel   = False

# generate a mapfile with all files in a single entry
delaysol_map.control.kind               = plugin
delaysol_map.control.type               = compressMapfile
delaysol_map.control.mapfile_in         = delay_cal_parmmap.output.mapfile
delaysol_map.control.mapfile_dir        = input.output.mapfile_dir
delaysol_map.control.filename           = delaysol_map.mapfile

# collect all h5parms into one
h5_imp_delaysol_map.control.kind                = recipe
h5_imp_delaysol_map.control.type                = executable_args
h5_imp_delaysol_map.control.executable          = {{ losoto_directory }}/bin/H5parm_collector.py
h5_imp_delaysol_map.control.error_tolerance     = {{ error_tolerance }}
h5_imp_delaysol_map.control.mapfile_in          = delaysol_map.output.mapfile
h5_imp_delaysol_map.control.inputkey            = h5parm
h5_imp_delaysol_map.control.outputkey           = outh5parm
h5_imp_delaysol_map.argument.flags              = [-c,h5parm]
h5_imp_delaysol_map.argument.outh5parm          = outh5parm

# make a losoto parset
make_losoto.control.kind                             = plugin
make_losoto.control.type                             = makeLosotoParset
make_losoto.control.steps                            = [plotA1,flag,flagextend,plotA2,merge,plotP3,plotPd,plotAi3]
make_losoto.control.filename                         = input.output.job_directory/losoto.parset
make_losoto.control.global.ncpu                      = 0
make_losoto.control.plotA1.operation                 =   PLOT
make_losoto.control.plotA1.soltab                    =   sol000/amplitude000
make_losoto.control.plotA1.axesInPlot                =   [time,freq]
make_losoto.control.plotA1.axisInTable               =   ant
make_losoto.control.plotA1.plotFlag                  =   True
make_losoto.control.plotA1.prefix                    =   {{ inspection_directory }}/delay_cal_ampBFlag_
make_losoto.control.flag.operation                   =   FLAG
make_losoto.control.flag.soltab                      =   sol000/amplitude000
make_losoto.control.flag.axesToFlag                  =   [time]
make_losoto.control.flag.order                       =   [100]
make_losoto.control.flag.maxCycles                   =   1
make_losoto.control.flag.maxRms                      =   5
make_losoto.control.flag.replce                      =   False
make_losoto.control.flag.preFlagZeros                =   False
make_losoto.control.flag.mode                        =   smooth
make_losoto.control.flagextend.operation             =   FLAGEXTEND
make_losoto.control.flagextend.soltab                =   sol000/amplitude000
make_losoto.control.flagextend.axesToExt             =   [freq,time]
make_losoto.control.flagextend.size                  =   [50,100]
make_losoto.control.flagextend.percent               =   50
make_losoto.control.flagextend.maxCycles             =   3
make_losoto.control.plotA2.operation                 =   PLOT
make_losoto.control.plotA2.soltab                    =   sol000/amplitude000
make_losoto.control.plotA2.axesInPlot                =   [time,freq]
make_losoto.control.plotA2.axisInTable               =   ant
make_losoto.control.plotA2.plotFlag                  =   True
make_losoto.control.plotA2.prefix                    =   {{ inspection_directory }}/delay_cal_ampAFlag_
make_losoto.control.merge.operation                  =   REWEIGHT
make_losoto.control.merge.mode                       =   copy
make_losoto.control.merge.soltab                     =   sol000/phase000
make_losoto.control.merge.soltabImport               =   amplitude000
make_losoto.control.plotP3.operation                 =   PLOT
make_losoto.control.plotP3.soltab                    =   sol000/phase000
make_losoto.control.plotP3.axesInPlot                =   [time,freq]
make_losoto.control.plotP3.axisInTable               =   ant
make_losoto.control.plotP3.plotFlag                  =   True
make_losoto.control.plotP3.prefix                    =   {{ inspection_directory }}/delay_cal_ph_
make_losoto.control.plotP3.refAnt                    =   ST001
make_losoto.control.plotP3.minmax                    =   [-3.14,3.14]
make_losoto.control.plotPd.operation                 =   PLOT
make_losoto.control.plotPd.soltab                    =   sol000/phase000
make_losoto.control.plotPd.axesInPlot                =   [time,freq]
make_losoto.control.plotPd.axisInTable               =   ant
make_losoto.control.plotPd.axisDiff                  =   pol
make_losoto.control.plotPd.plotFlag                  =   True
make_losoto.control.plotPd.prefix                    =   {{ inspection_directory }}/delay_cal_ph_poldif
make_losoto.control.plotPd.refAnt                    =   ST001
make_losoto.control.plotPd.minmax                    =   [-3.14,3.14]
make_losoto.control.plotAi3.operation                =   PLOT
make_losoto.control.plotAi3.soltab                   =   sol000/amplitude000
make_losoto.control.plotAi3.axesInPlot               =   [time,freq]
make_losoto.control.plotAi3.axisInTable              =   ant
make_losoto.control.plotAi3.plotFlag                 =   True
make_losoto.control.plotAi3.prefix                   =   {{ inspection_directory }}/delay_cal_amp_

# run losoto to get nice plots
process_losoto.control.kind                          =  recipe
process_losoto.control.type                          =  executable_args
process_losoto.control.executable                    =  {{ losoto_directory }}/bin/losoto
process_losoto.control.max_per_node                  =  {{ num_proc_per_node }}
process_losoto.control.mapfile_in                    =  h5_imp_delaysol_map.output.mapfile
process_losoto.control.inputkey                      =  h5in
process_losoto.argument.flags                        =  [h5in,{{ job_directory }}/losoto.parset]


# copy the LoSoTo file to the inspection_directory
copy_h5imp_cal.control.kind               =  recipe
copy_h5imp_cal.control.type               =  executable_args
copy_h5imp_cal.control.executable         =  /bin/cp
copy_h5imp_cal.control.mapfile_in         =  h5_imp_delaysol_map.output.mapfile
copy_h5imp_cal.control.inputkey           =  h5in
copy_h5imp_cal.control.arguments          =  [h5in, {{ cal_values_directory }}/delay_cal.h5]

# in delay cal parmdb, copy ST values to CS values
copyST_gains.control.type                            = pythonplugin
copyST_gains.control.executable                      = {{ scripts }}/gains_toCS_h5parm.py
copyST_gains.argument.flags                          = [h5_imp_delaysol_map.output.mapfile,dpppconcat.output.mapfile]

# expand the mapfile so there's one entry per ms
expand_h5_map.control.kind                      = plugin
expand_h5_map.control.type                      = expandMapfile
expand_h5_map.control.mapfile_in                = h5_imp_delaysol_map.output.mapfile
expand_h5_map.control.mapfile_to_match          = dpppconcat.output.mapfile
expand_h5_map.control.mapfile_dir               = input.output.mapfile_dir
expand_h5_map.control.filename                  = expand_h5_map.mapfile

# Apply the gain solutions directly to the data -- no need to remove time dependence
ndppp_apply_delay.control.type                           = dppp
ndppp_apply_delay.control.inplace                        = True
ndppp_apply_delay.control.max_per_node                   = {{ num_proc_per_node }}
ndppp_apply_delay.control.error_tolerance                = {{ error_tolerance }}
ndppp_apply_delay.control.mapfiles_in                    = [dpppconcat.output.mapfile,expand_h5_map.output.mapfile]
ndppp_apply_delay.control.inputkeys                      = [inputms,h5parm]
ndppp_apply_delay.argument.numthreads                    = {{ max_dppp_threads }}
ndppp_apply_delay.argument.msin                          = inputms
ndppp_apply_delay.argument.msin.datacolumn               = {{ delaycal_col }}
ndppp_apply_delay.argument.msin.baseline                 = *&
ndppp_apply_delay.argument.msout.datacolumn              = CORRECTED_DATA
ndppp_apply_delay.argument.msout.writefullresflag        = False
ndppp_apply_delay.argument.msout.storagemanager          = dysco
ndppp_apply_delay.argument.steps                         = [applyDelayAmp,applyDelayPhase,count]
ndppp_apply_delay.argument.applyDelayAmp.type            = applycal
ndppp_apply_delay.argument.applyDelayAmp.parmdb          = h5parm
ndppp_apply_delay.argument.applyDelayAmp.correction      = amplitude000
ndppp_apply_delay.argument.applyDelayAmp.solset          = sol001
ndppp_apply_delay.argument.applyDelayAmp.updateweights   = false
ndppp_apply_delay.argument.applyDelayPhase.type          = applycal
ndppp_apply_delay.argument.applyDelayPhase.parmdb        = h5parm
ndppp_apply_delay.argument.applyDelayPhase.correction    = phase000
ndppp_apply_delay.argument.applyDelayPhase.solset        = sol001
ndppp_apply_delay.argument.applyDelayPhase.updateweights = false

##################################################################
#                                                               ##
#                   END OF PIPELINE                            ##
#                                                         ##
##################################################################

