##################################################################
## LOFAR long baseline calibration pipeline parset              ##
##  - This pipeline requires prefactor V3                       ##
##    to have already been run on both calibrator               ##
##    and target.                                               ##
##  - The working and runtime directory are expected            ##
##    to be the same.                                           ##
##  - Please report any issues at                               ##
##    https://github.com/lmorabit/lofar-vlbi        		##
##################################################################


##########################################################
## Please update these parameters.                      ##
##########################################################

# local software paths
! lofar_vlbi_dir            		= /home/morabito/software/lofar-vlbi
! prefactor_dir                         = /home/morabito/software/prefactor
! selfcal_dir				= /home/morabito/software/lofar_facet_selfcal
! helper_dir				= /home/morabito/software/lofar_helpers
# the following are in the singularity image and should not need to be changed
! losoto_directory                      = /opt/lofar/pyenv-py2
! lofar_directory                       = $LOFARROOT
! working_directory         =  input.output.working_directory/input.output.job_name               ## specify the working_directory (intermediate data products)

## target data information
! target_input_path             = /data/scratch/lb_bw/targetdata
! target_input_pattern          = L*.MS

## Prefactor solution information
## assumes the job directory and Pre-Facet-Target will be in the same parent directory
! prefac_tgt_dir	= input.output.job_directory/../Pre-Facet-Target
! cal_solutions         = {{ prefac_tgt_dir }}/results/cal_values/solutions.h5  ## location of h5parm from prefactor - should contain 'calibrator' and 'target' information
! solutions             = input.output.job_directory/solutions.h5
! phasesol              = TGSSphase

## Stations to flag and filter
! flag_baselines        = [ ] ## flag baselines, eg: [ CS013HBA*&&* ]
! filter_baselines	=   *& ## filter baselines that are flagged, e.g.: !CS013HBA*&&*

## averaging information -- do not touch unless you know what you are doing!
! cal_avg_freqresolution    = 390.56kHz
! cal_avg_timeresolution    = 32.

## flagging and a-team clipping settings
! rfistrategy                       =  {{ prefactor_dir }}/rfistrategies/HBAdefault.rfis   ## this may need to be changed to the cwl version depending on the singularity image used
! min_separation                    =  30         ## minimal accepted distance to an A-team source on the sky in degrees (will raise a WARNING)

###########################################################
### DDF Options -- please check even if not using        ##
###########################################################

! substep_ddf             = #,apply_ddf   ## set to apply_ddf to use, leave blank otherwise
! ddf_soldir              = # /data/scratch/lb_bw/targetddf/L602888/SOLSDIR     ## path to 'SOLSDIR' from ddf-pipeline run, leave blank otherwise
! delaycal_col            = DATA ## set to DATA_DI_CORRECTED if applying ddf solutions, leave as DATA otherwise.

##########################################################
## These parameters may need to be updated.             ##
##########################################################

## for proper concatenation
! reference_stationSB           = 104

## Station combination
! phaseup_command               = {ST001:'CS*'} ## 'CS*' for all core stations (or select stations you want to use)
! filter_command                = '!CS*&&*' ## remove the core stations after combination

## job and output directories
! job_directory                 = input.output.job_directory 
! log_file                      = input.output.log_file                                               ## location of the logfile
! results_directory             = {{ job_directory }}/results
! inspection_directory          = {{ results_directory }}/inspection/
! cal_values_directory          = {{ results_directory }}/calibrator_results/

## selfcal config
! delay_config_file 		= {{ lofar_vlbi_dir }}/facetselfcal_config.txt

## catalogue information
## if using your own field catalogue (i.e., ddf-pipeline generated catalogue), point lotss_skymodel to it on disk
! lotss_skymodel         = {{ results_directory }}/lotss_catalogue.csv
! lbcs_skymodel          = {{ results_directory }}/lbcs_catalogue.csv
! image_cat              = {{ results_directory }}/image_catalogue.csv
! delay_cat              = {{ results_directory }}/delay_calibrators.csv
! continue_without_lotss = True

## setup for running steps
! substep_clip     = ,clipATeam     ## turn on if you want to a-team clip (will take several days)
! substep_flag     = ,aoflagging    ## aoflagging
! substep_delay    = ,delaycal        ## do a single in-field delay calibration
! substep_apply    = ,applydelay      ## apply the delay solutions back to the data
! substep_cleanup  = ,cleanup	      ## delete files not needed for Split-Directions.parset

##########################################################
## Changing these will probably break something.        ##
##########################################################

## global information
! base_directory          = input.output.working_directory  
! job_directory           = input.output.job_directory      
! scripts                 = {{ lofar_vlbi_dir }}/bin
! prefactor_scripts       = {{ prefactor_dir }}/scripts

##########################################################
##  Cluster-specific configuration: adjust as needed    ##
##########################################################

## parameters for pipeline performance
! min_length                        =  5          ## minimum amount of chunks to concatenate in frequency necessary to perform the wide-band flagging in the RAM. It data is too big aoflag will use indirect-read.
! overhead                          =  0.5        ## Only use this fraction of the available memory for deriving the amount of data to be concatenated.
## Runtime setup -- will depend on your computing cluster
! num_proc_per_node                 = input.output.max_per_node    ## number of processes to use per step per node
! num_proc_per_node_limit           = 6     ## number of processes to use per step per node for tasks with high i/o (dppp or cp) or memory (eg calibration)
! max_dppp_threads                  = 5     ## number of threads per process for NDPPP
! error_tolerance                   = False ## False = stop if any subband fails, True = keep going

##
## END CONFIGURATION


##########################################################
## Steps to run.                                        ##
##########################################################

pipeline.steps = [ setup, prep {{ substep_clip }} ,concat {{ substep_ddf }} {{ substep_flag }} ,phaseup {{ substep_delay }} {{ substep_apply }} {{ substep_cleanup }} ]

pipeline.steps.setup = [ mk_results_dir, mk_inspect_dir, mk_cal_values_dir, createmap_target, createmap_target_list, cp_cal_solutions, check_station_mismatch, download_cats ]
pipeline.steps.prep = [ ndppp_prep_target, ndppp_prep_target_list ]
pipeline.steps.clipATeam   =  [ create_ateam_model_map, make_sourcedb_ateam, expand_sourcedb_ateam, predict_ateam, ateamcliptar]
pipeline.steps.concat = [ sort_concatmap, do_sortmap_maps, dpppconcat, dpppconcat_list ]
pipeline.steps.apply_ddf = [ createmap_ddf, ddf_solutions, ddf_h5parms, convert_to_h5, expand_concat_map, addIS, ndppp_applycal ]
pipeline.steps.aoflagging = [ aoflag ]
pipeline.steps.phaseup = [ prep_delay_dir, dppp_phaseup, dppp_phaseup_list, sort_phaseupmap, do_phaseup_maps, phaseup_concat ]
pipeline.steps.delaycal = [ delay_cal_model, delay_solve ]
pipeline.steps.applydelay = [ createmap_selfcal, copyST_gains, createmap_linear, copy_delay_sols, expand_h5_map, ndppp_apply_delay ]
pipeline.steps.cleanup = [ delete_prep_target, delete_phaseup, make_results_compress, make_summary ]

##################################################################################################################
##                                                                                                              ##
##            BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!                                                    ##
##                                                                                                              ##
##################################################################################################################

#######################################
## SETUP

# create the results directory if needed
mk_results_dir.control.kind               = plugin
mk_results_dir.control.type               = makeDirectory
mk_results_dir.control.directory          = {{ results_directory }}

# create the inspection_directory if needed
mk_inspect_dir.control.kind               = plugin
mk_inspect_dir.control.type               = makeDirectory
mk_inspect_dir.control.directory          = {{ inspection_directory }}

# create the cal_values_directory if needed
mk_cal_values_dir.control.kind            =  plugin
mk_cal_values_dir.control.type            =  makeDirectory
mk_cal_values_dir.control.directory       =  {{ cal_values_directory }}

# generate a mapfile of all the target data
createmap_target.control.kind             = plugin
createmap_target.control.type             = makeTargetmap
createmap_target.control.method           = mapfile_from_folder
createmap_target.control.mapfile_dir      = input.output.mapfile_dir
createmap_target.control.filename         = createmap_target.mapfile
createmap_target.control.folder           = {{ target_input_path }}
createmap_target.control.pattern          = {{ target_input_pattern }}
createmap_target.control.ddf_solsdir      = {{ ddf_soldir }}
createmap_target.control.prefacet_dir     = {{ prefac_tgt_dir }}
createmap_target.control.solname          = {{ cal_solutions }}

# convert to a mapfile with all subbands in one list
createmap_target_list.control.kind            =   plugin
createmap_target_list.control.type            =   createMapfile
createmap_target_list.control.method          =   mapfile_all_to_one
createmap_target_list.control.mapfile_dir     =   input.output.mapfile_dir
createmap_target_list.control.filename        =   createmap_target_list.mapfile
createmap_target_list.control.mapfile_in      =   createmap_target.output.mapfile

# copy the cal solutions to operate on
cp_cal_solutions.control.kind                 = recipe
cp_cal_solutions.control.type                 = executable_args
cp_cal_solutions.control.executable           = /bin/cp
cp_cal_solutions.control.max_per_node         = 1
cp_cal_solutions.control.skip_infile          = True
cp_cal_solutions.control.mapfile_in           = createmap_target_list.output.mapfile
cp_cal_solutions.argument.flags               = [{{ cal_solutions }}, {{ solutions }}]

# check for station mismatch 
check_station_mismatch.control.kind                            =   plugin
check_station_mismatch.control.type                            =   compareStationListVLBI
check_station_mismatch.control.mapfile_in                      =   createmap_target.output.mapfile
check_station_mismatch.control.solset_name		       =   vlbi
check_station_mismatch.control.h5parmdb                        =   {{ solutions }}
check_station_mismatch.control.filter                          =   {{ filter_baselines }}

# download the relevant catalogues
download_cats.control.kind                    = plugin
download_cats.control.type                    = DownloadCats
download_cats.control.mapfile_in              = createmap_target_list.output.mapfile
download_cats.control.lotss_radius            = 1.5
download_cats.control.lbcs_radius             = 1.5
download_cats.control.im_radius		      = 1.24
download_cats.control.lotss_catalogue         = {{ lotss_skymodel }}
download_cats.control.lbcs_catalogue          = {{ lbcs_skymodel }}
download_cats.control.lotss_result_file       = {{ image_cat }}
download_cats.control.delay_cals_file         = {{ delay_cat }}
download_cats.control.match_tolerance         = 5.
download_cats.control.bright_limit_Jy         = 5.
download_cats.control.image_limit_Jy          = 0.01
download_cats.control.continue_no_lotss       = {{ continue_without_lotss }}
       
# run NDPPP on the target data to flag and apply solutions
ndppp_prep_target.control.type                          = dppp
ndppp_prep_target.control.max_per_node                  = {{ num_proc_per_node_limit }}
ndppp_prep_target.control.error_tolerance               = {{ error_tolerance }}
ndppp_prep_target.argument.numthreads                   = 2
ndppp_prep_target.argument.msin                         = createmap_target.output.mapfile  
ndppp_prep_target.argument.msin.datacolumn              = DATA
ndppp_prep_target.argument.msin.baseline                = check_station_mismatch.output.filter
ndppp_prep_target.argument.msout.datacolumn             = DATA
ndppp_prep_target.argument.msout.storagemanager         = dysco
ndppp_prep_target.argument.msout.writefullresflag       = False
ndppp_prep_target.argument.msout                        = .
ndppp_prep_target.argument.steps                        = [flag,flagamp,filter,applyPA,applybandpass,applyclock,applybeam,applyRM,applyphase,count]
ndppp_prep_target.argument.flag.type                    = preflagger
ndppp_prep_target.argument.flag.baseline                = {{ flag_baselines }}
ndppp_prep_target.argument.flagamp.type                 = preflagger
ndppp_prep_target.argument.flagamp.amplmin              = 1e-30
ndppp_prep_target.argument.filter.type                  = filter
ndppp_prep_target.argument.filter.baseline              = check_station_mismatch.output.filter
ndppp_prep_target.argument.filter.remove                = true
ndppp_prep_target.argument.applyclock.type              = applycal
ndppp_prep_target.argument.applyclock.parmdb            = {{ solutions }}
ndppp_prep_target.argument.applyclock.correction        = clock
ndppp_prep_target.argument.applyclock.solset            = calibrator
ndppp_prep_target.argument.applyPA.type                 = applycal
ndppp_prep_target.argument.applyPA.parmdb               = {{ solutions }}
ndppp_prep_target.argument.applyPA.correction           = polalign
ndppp_prep_target.argument.applyPA.solset               = calibrator
ndppp_prep_target.argument.applybandpass.type           = applycal
ndppp_prep_target.argument.applybandpass.parmdb         = {{ solutions }}
ndppp_prep_target.argument.applybandpass.correction     = bandpass
ndppp_prep_target.argument.applybandpass.updateweights  = True
ndppp_prep_target.argument.applybandpass.solset         = calibrator
ndppp_prep_target.argument.applybeam.type               = applybeam
ndppp_prep_target.argument.applybeam.usechannelfreq     = True
ndppp_prep_target.argument.applybeam.updateweights      = True
ndppp_prep_target.argument.applyRM.type                 = applycal
ndppp_prep_target.argument.applyRM.parmdb               = {{ solutions }}
ndppp_prep_target.argument.applyRM.correction           = RMextract
ndppp_prep_target.argument.applyRM.solset               = target
ndppp_prep_target.argument.applyphase.type              = applycal
ndppp_prep_target.argument.applyphase.parmdb            = {{ solutions }}
ndppp_prep_target.argument.applyphase.correction        = {{ phasesol }}
ndppp_prep_target.argument.applyphase.solset            = target

# combine all entries into one mapfile
ndppp_prep_target_list.control.kind                                =   plugin
ndppp_prep_target_list.control.type                                =   createMapfile
ndppp_prep_target_list.control.method                              =   mapfile_all_to_one
ndppp_prep_target_list.control.mapfile_dir                         =   input.output.mapfile_dir
ndppp_prep_target_list.control.filename                            =   ndppp_prep_target_list.mapfile
ndppp_prep_target_list.control.mapfile_in                          =   ndppp_prep_target.output.mapfile

##################################################################
#                                                               ##
#                     CLIP THE A-TEAM                           ##
#                                                               ##
##################################################################

# create a mapfile with the A-Team skymodel, length = 1
create_ateam_model_map.control.kind                            =   plugin
create_ateam_model_map.control.type                            =   addListMapfile
create_ateam_model_map.control.hosts                           =   ['localhost']
create_ateam_model_map.control.files                           =   [ {{ prefactor_dir }}/skymodels/Ateam_LBA_CC.skymodel ]
create_ateam_model_map.control.mapfile_dir                     =   input.output.mapfile_dir
create_ateam_model_map.control.filename                        =   ateam_model_name.mapfile

# make sourcedbs from the A-Team skymodel, length = 1
make_sourcedb_ateam.control.kind                               =   recipe
make_sourcedb_ateam.control.type                               =   executable_args
make_sourcedb_ateam.control.executable                         =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb_ateam.control.error_tolerance                    =   {{ error_tolerance }}
make_sourcedb_ateam.control.args_format                        =   lofar
make_sourcedb_ateam.control.outputkey                          =   out
make_sourcedb_ateam.control.mapfile_in                         =   create_ateam_model_map.output.mapfile
make_sourcedb_ateam.control.inputkey                           =   in
make_sourcedb_ateam.argument.format                            =   <
make_sourcedb_ateam.argument.outtype                           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_ateam.control.kind                             =   plugin
expand_sourcedb_ateam.control.type                             =   expandMapfile
expand_sourcedb_ateam.control.mapfile_in                       =   make_sourcedb_ateam.output.mapfile
expand_sourcedb_ateam.control.mapfile_to_match                 =   ndppp_prep_target.output.mapfile
expand_sourcedb_ateam.control.mapfile_dir                      =   input.output.mapfile_dir
expand_sourcedb_ateam.control.filename                         =   expand_sourcedb_ateam.datamap

# Predict, corrupt, and predict the ateam-resolution model, length = nfiles
predict_ateam.control.type                                     =   dppp
predict_ateam.control.mapfiles_in                              =   [ndppp_prep_target.output.mapfile,expand_sourcedb_ateam.output.mapfile]
predict_ateam.control.inputkeys                                =   [msin,sourcedb]
predict_ateam.control.inplace                                  =   True
predict_ateam.control.max_per_node                             =   {{ num_proc_per_node_limit }}
predict_ateam.control.error_tolerance                          =   {{ error_tolerance }}
predict_ateam.argument.numthreads                              =   {{ max_dppp_threads }}
predict_ateam.argument.msin.datacolumn                         =   DATA
predict_ateam.argument.msout.datacolumn                        =   MODEL_DATA
predict_ateam.argument.msout.storagemanager                    =   dysco
predict_ateam.argument.msout.storagemanager.databitrate        =   0
predict_ateam.argument.steps                                   =   [filter,predict]
predict_ateam.argument.filter.type                             =   filter
predict_ateam.argument.filter.baseline                         =   [CR]S*&
predict_ateam.argument.filter.remove                           =   False
predict_ateam.argument.predict.type                            =   predict
predict_ateam.argument.predict.operation                       =   replace
predict_ateam.argument.predict.sourcedb                        =   sourcedb
predict_ateam.argument.predict.sources                         =   [VirA_4_patch,CygAGG,CasA_4_patch,TauAGG]
predict_ateam.argument.predict.usebeammodel                    =   True
predict_ateam.argument.predict.usechannelfreq                  =   false
predict_ateam.argument.predict.onebeamperpatch                 =   True

# run the a-team clipper to flag data affected by the a-team
ateamcliptar.control.kind                                      =   recipe
ateamcliptar.control.type                                      =   executable_args
ateamcliptar.control.max_per_node                              =   {{ num_proc_per_node_limit }}
ateamcliptar.control.executable                                =   {{ prefactor_scripts }}/Ateamclipper.py
ateamcliptar.control.error_tolerance                           =   {{ error_tolerance }}
ateamcliptar.control.mapfile_in                                =   ndppp_prep_target.output.mapfile
ateamcliptar.control.arguments                                 =   [allms]
ateamcliptar.control.inputkey                                  =   allms

##################################################################
#                                                               ##
#                    CONCATENATION                              ##
#                                                               ##
##################################################################

# sort them by frequency and fill in missing subband information
sort_concatmap.control.type               = pythonplugin
sort_concatmap.control.executable         = {{ prefactor_scripts }}/sort_times_into_freqGroups.py
sort_concatmap.argument.flags             = [ndppp_prep_target_list.output.mapfile]
sort_concatmap.argument.filename          = sort_concatmap
sort_concatmap.argument.mapfile_dir       = input.output.mapfile_dir
sort_concatmap.argument.target_path       = {{ job_directory }}
sort_concatmap.argument.numSB             = 10
sort_concatmap.argument.NDPPPfill         = True
sort_concatmap.argument.stepname          = dpppconcat
sort_concatmap.argument.firstSB           = {{ reference_stationSB }}
sort_concatmap.argument.truncateLastSBs   = False

# convert the output of sort_concatmap into usable mapfile
do_sortmap_maps.control.kind              =  plugin
do_sortmap_maps.control.type              =  mapfilenamesFromMapfiles
do_sortmap_maps.control.mapfile_groupmap  =  sort_concatmap.output.groupmapfile.mapfile
do_sortmap_maps.control.mapfile_datamap   =  sort_concatmap.output.mapfile.mapfile

# concatenate into bands into a single measurement set
dpppconcat.control.type                  = dppp
dpppconcat.control.max_per_node          = {{ num_proc_per_node_limit }}
dpppconcat.control.error_tolerance       = {{ error_tolerance }}
dpppconcat.control.mapfile_out           = do_sortmap_maps.output.groupmap
dpppconcat.control.mapfiles_in           = [do_sortmap_maps.output.datamap]
dpppconcat.control.inputkey              = msin
dpppconcat.argument.msin.datacolumn      = DATA
dpppconcat.argument.msin.missingdata     = True
dpppconcat.argument.msin.orderms         = False
dpppconcat.argument.msout.datacolumn     = DATA
dpppconcat.argument.msout.writefullresflag = False
dpppconcat.argument.msout.storagemanager = dysco
dpppconcat.argument.msout.overwrite      = True
dpppconcat.argument.steps                = [count]
dpppconcat.argument.numthreads           = {{ max_dppp_threads }}

# make a mapfile with all blocks in one list
dpppconcat_list.control.kind            = plugin
dpppconcat_list.control.type            = createMapfile
dpppconcat_list.control.method          = mapfile_all_to_one
dpppconcat_list.control.mapfile_dir     = input.output.mapfile_dir
dpppconcat_list.control.filename        = dpppconcat_list.mapfile
dpppconcat_list.control.mapfile_in      = dpppconcat.output.mapfile


##################################################################
#                                                               ##
#                     AOFLAGGING                                ##
#                                                               ##
##################################################################

aoflag.control.type                                 =  dppp
aoflag.control.max_per_node                         =  {{ num_proc_per_node_limit }}
aoflag.control.error_tolerance                      =  {{ error_tolerance }}
aoflag.control.mapfile_in                           =  dpppconcat.output.mapfile
aoflag.control.inputkey                             =  input_file
aoflag.control.inplace                              =  True
aoflag.argument.numthreads                          =  {{ max_dppp_threads }}
aoflag.argument.msin                                =  input_file
aoflag.argument.msin.datacolumn                     =  DATA
aoflag.argument.steps                               =  [aoflagger]
aoflag.argument.aoflagger.type                      =  aoflagger
aoflag.argument.aoflagger.memoryperc                =  15
aoflag.argument.aoflagger.keepstatistics            =  true
aoflag.argument.aoflagger.strategy                  =  {{ rfistrategy }}

###################################################################
##                                                               ##
##            OPTIONAL -- APPLY DDF SOLUTIONS                    ##
##                                                               ##
###################################################################

# find the ddf solutions
createmap_ddf.control.kind             = plugin
createmap_ddf.control.type             = createMapfile
createmap_ddf.control.method           = mapfile_from_folder
createmap_ddf.control.mapfile_dir      = input.output.mapfile_dir
createmap_ddf.control.filename         = createmap_ddf.mapfile
createmap_ddf.control.folder           = {{ ddf_soldir }}
createmap_ddf.control.pattern          = L*pre-cal.ms

# get mapfile of npz
ddf_solutions.control.kind               =  plugin
ddf_solutions.control.type               =  createMapfile
ddf_solutions.control.method             =  add_suffix_to_file
ddf_solutions.control.mapfile_in         =  createmap_ddf.output.mapfile
ddf_solutions.control.add_suffix_to_file =  /killMS.DIS2_full.sols.npz
ddf_solutions.control.mapfile_dir        =  input.output.mapfile_dir
ddf_solutions.control.filename          =  ddf_solutions.mapfile

# make mapfile for output h5parms
ddf_h5parms.control.kind              = plugin
ddf_h5parms.control.type              = makeResultsMapfile
ddf_h5parms.control.mapfile_dir       = input.output.mapfile_dir
ddf_h5parms.control.filename          = ddf_h5parms.mapfile
ddf_h5parms.control.mapfile_in        = createmap_ddf.output.mapfile
ddf_h5parms.control.target_dir        = {{ job_directory }}
ddf_h5parms.control.new_suffix        = _ddf.h5

# run losoto to convert
convert_to_h5.control.kind              = recipe
convert_to_h5.control.type              = executable_args
convert_to_h5.control.executable        = {{ losoto_directory }}/bin/killMS2H5parm.py
convert_to_h5.control.max_per_node      = {{ num_proc_per_node }}
convert_to_h5.control.mapfiles_in       = [ddf_h5parms.output.mapfile,ddf_solutions.output.mapfile]
convert_to_h5.control.inputkeys         = [outputh5,inputnpz]
convert_to_h5.argument.flags            = [outputh5,inputnpz]

# expand the output to one entry per ms
expand_concat_map.control.kind                      = plugin
expand_concat_map.control.type                      = expandMapfile
expand_concat_map.control.mapfile_in                = dpppconcat.output.mapfile
expand_concat_map.control.mapfile_to_match          = ddf_h5parms.output.mapfile
expand_concat_map.control.mapfile_dir               = input.output.mapfile_dir
expand_concat_map.control.filename                  = expand_concat_map.mapfile

# add the international stations
addIS.control.type                  = pythonplugin
addIS.control.executable            = {{ lofar_vlbi_dir }}/bin/addIS_to_h5.py
addIS.control.max_per_node          = {{ num_proc_per_node }}
addIS.control.mapfiles_in           = [expand_concat_map.output.mapfile,ddf_h5parms.output.mapfile]
addIS.control.inputkeys             = [msin,h5parms]
addIS.argument.solset_in            = sol000
addIS.argument.solset_out           = sol001
addIS.argument.do_int_stations      = True
addIS.argument.flags                = [h5parms,msin]

# apply the solutions
ndppp_applycal.control.type                    = dppp
ndppp_applycal.control.max_per_node            = {{ num_proc_per_node_limit }}
ndppp_applycal.control.error_tolerance         = {{ error_tolerance }}
ndppp_applycal.control.mapfiles_in              = [dpppconcat.output.mapfile,ddf_h5parms.output.mapfile]
ndppp_applycal.control.inputkeys                = [msins,parmdbs]
ndppp_applycal.control.inplace                 = True
ndppp_applycal.argument.numthreads             = {{ max_dppp_threads }}
ndppp_applycal.argument.msin                    = msins
ndppp_applycal.argument.msin.datacolumn        = DATA
ndppp_applycal.argument.msout.datacolumn       = {{ delaycal_col }}
ndppp_applycal.argument.msout.writefullresflag = False
ndppp_applycal.argument.msout.storagemanager   = dysco
ndppp_applycal.argument.steps                  = [applyddf]
ndppp_applycal.argument.applyddf.type           = applycal
ndppp_applycal.argument.applyddf.parmdb         = parmdbs
ndppp_applycal.argument.applyddf.correction     = fulljones
ndppp_applycal.argument.applyddf.solset         = sol001
ndppp_applycal.argument.applyddf.soltab         = [amplitude000,phase000]
###################################################################
##                                                               ##
##              PHASEUP AND CONCATENATION                        ##
##                                                               ##
###################################################################

# convert the best delay calibrator from catalogue to output mapfile
prep_delay_dir.control.kind             = plugin
prep_delay_dir.control.type             = TargetListToMapfile
prep_delay_dir.control.mapfile_dir      = input.output.mapfile_dir
prep_delay_dir.control.mapfile_in       = dpppconcat.output.mapfile
prep_delay_dir.control.filename         = prep_delay_dir.mapfile
prep_delay_dir.control.target_file      = {{ delay_cat }}
prep_delay_dir.control.all_to_one       = False

# shift, average and add up stations for tied array
dppp_phaseup.control.type                  	= dppp
dppp_phaseup.control.max_per_node          	= {{ num_proc_per_node }}
dppp_phaseup.control.mapfile_out           	= prep_delay_dir.output.mapfile
dppp_phaseup.argument.msin                 	= dpppconcat.output.mapfile
dppp_phaseup.argument.msin.datacolumn      	= {{ delaycal_col }}
dppp_phaseup.argument.msout.datacolumn     	= DATA
dppp_phaseup.argument.msout.storagemanager 	= dysco
dppp_phaseup.argument.msout.overwrite      	= True
dppp_phaseup.argument.steps                	= [shift, average1, applybeam, average2]
dppp_phaseup.argument.shift.type           	= phaseshift
dppp_phaseup.argument.shift.phasecenter    	= prep_delay_dir.output.coords
dppp_phaseup.argument.average1.type             = averager
dppp_phaseup.argument.average1.freqresolution   = 48.82kHz
dppp_phaseup.argument.average1.timeresolution   = 4.
dppp_phaseup.argument.applybeam.type		= applybeam
dppp_phaseup.argument.applybeam.direction		=  prep_delay_dir.output.coords
dppp_phaseup.argument.applybeam.beammode	= full
dppp_phaseup.argument.average2.type 		= averager
dppp_phaseup.argument.average2.freqresolution 	= {{ cal_avg_freqresolution }}
dppp_phaseup.argument.average2.timeresolution 	= {{ cal_avg_timeresolution }}
dppp_phaseup.argument.numthreads           	= {{ max_dppp_threads }}

# convert to a mapfile with all bands in one list
dppp_phaseup_list.control.kind            =   plugin
dppp_phaseup_list.control.type            =   createMapfile
dppp_phaseup_list.control.method          =   mapfile_all_to_one
dppp_phaseup_list.control.mapfile_dir     =   input.output.mapfile_dir
dppp_phaseup_list.control.filename        =   dppp_phaseup_list.mapfile
dppp_phaseup_list.control.mapfile_in      =   dppp_phaseup.output.mapfile

# sort them by frequency and fill in missing subband information
sort_phaseupmap.control.type               = pythonplugin
sort_phaseupmap.control.executable         = {{ prefactor_scripts }}/sort_times_into_freqGroups.py
sort_phaseupmap.argument.flags             = [dppp_phaseup_list.output.mapfile]
sort_phaseupmap.argument.filename          = sort_phaseupmap
sort_phaseupmap.argument.mapfile_dir       = input.output.mapfile_dir
sort_phaseupmap.argument.target_path       = {{ job_directory }}
sort_phaseupmap.argument.numSB             = -1
sort_phaseupmap.argument.NDPPPfill         = True
sort_phaseupmap.argument.stepname          = dpppconcat
sort_phaseupmap.argument.firstSB           = None
sort_phaseupmap.argument.truncateLastSBs   = False

# convert the output of sort_phaseupmap into usable mapfile
do_phaseup_maps.control.kind              =  plugin
do_phaseup_maps.control.type              =  mapfilenamesFromMapfiles
do_phaseup_maps.control.mapfile_groupmap  =  sort_phaseupmap.output.groupmapfile.mapfile
do_phaseup_maps.control.mapfile_datamap   =  sort_phaseupmap.output.mapfile.mapfile

# concatenate them
phaseup_concat.control.type                    = dppp
phaseup_concat.control.max_per_node            = {{ num_proc_per_node_limit }}
phaseup_concat.control.error_tolerance         = {{ error_tolerance }}
phaseup_concat.control.mapfiles_out            = do_phaseup_maps.output.groupmap
phaseup_concat.control.mapfiles_in             = [do_phaseup_maps.output.datamap]
phaseup_concat.control.inputkey                = msin
phaseup_concat.argument.msin.datacolumn        = DATA
phaseup_concat.argument.msin.missingdata       = True
phaseup_concat.argument.msin.orderms           = False
phaseup_concat.argument.msout.datacolumn       = DATA
phaseup_concat.argument.msout.writefullresflag = False
phaseup_concat.argument.msout.storagemanager   = dysco
phaseup_concat.argument.msout.overwrite        = True
phaseup_concat.argument.steps                  = [count]
phaseup_concat.argument.numthreads             = {{ max_dppp_threads }}

# generate the calibrator model with skynet
delay_cal_model.control.type                  = pythonplugin
delay_cal_model.control.executable            = {{ scripts }}/skynet.py
delay_cal_model.control.mapfile_in            = phaseup_concat.output.mapfile
delay_cal_model.control.inputkey              = msin
delay_cal_model.argument.flags                = [msin]
delay_cal_model.argument.delayCalFile         = {{ delay_cat }}

# run self-calibration
delay_solve.control.type                  	= pythonplugin
delay_solve.control.executable            	= {{ scripts }}/run_selfcal.py
delay_solve.control.mapfile_in             	= phaseup_concat.output.mapfile
delay_solve.control.inputkey               	= msin
delay_solve.argument.flags                 	= [msin]
delay_solve.argument.helperscriptspath     	= {{ selfcal_dir }}
delay_solve.argument.helperscriptspath_h5merge  = {{ helper_dir }}
delay_solve.argument.configfile         	= {{ delay_config_file }}
delay_solve.argument.destdir            	= {{ job_directory }}

# generate mapfile of the output file
createmap_selfcal.control.kind             = plugin
createmap_selfcal.control.type             = createMapfile
createmap_selfcal.control.method           = mapfile_from_folder
createmap_selfcal.control.mapfile_dir      = input.output.mapfile_dir
createmap_selfcal.control.filename         = createmap_selfcal.mapfile
createmap_selfcal.control.folder           = {{ job_directory }}/delay_solve
createmap_selfcal.control.pattern          = merged_selfcalcyle009_*.h5

# in delay cal h5parm, convert to linear and copy ST001 sols to CS
copyST_gains.control.type                            = pythonplugin
copyST_gains.control.executable                      = {{ scripts }}/run_h5merger.py
copyST_gains.argument.flags                          = [createmap_selfcal.output.mapfile,dpppconcat.output.mapfile]
copyST_gains.argument.helperscriptspath_h5merge      = {{ helper_dir }}

# generate mapfile of the linear + CS solutions
createmap_linear.control.kind             = plugin
createmap_linear.control.type             = createMapfile
createmap_linear.control.method           = mapfile_from_folder
createmap_linear.control.mapfile_dir      = input.output.mapfile_dir
createmap_linear.control.filename         = createmap_selfcal.mapfile
createmap_linear.control.folder           = {{ job_directory }}
createmap_linear.control.pattern          = *_toapply.h5
 

# copy the h5parm to the inspection_directory
copy_delay_sols.control.kind               =  recipe
copy_delay_sols.control.type               =  executable_args
copy_delay_sols.control.executable         =  /bin/cp
copy_delay_sols.control.mapfile_in         =  createmap_linear.output.mapfile
copy_delay_sols.control.inputkey           =  h5in
copy_delay_sols.control.arguments          =  [h5in, {{ cal_values_directory }}/delay_cal_sols.h5]

# expand the mapfile so there's one entry per ms
expand_h5_map.control.kind                      = plugin
expand_h5_map.control.type                      = expandMapfile
expand_h5_map.control.mapfile_in                = createmap_linear.output.mapfile
expand_h5_map.control.mapfile_to_match          = dpppconcat.output.mapfile
expand_h5_map.control.mapfile_dir               = input.output.mapfile_dir
expand_h5_map.control.filename                  = expand_h5_map.mapfile

# Apply the gain solutions directly to the data -- no need to remove time dependence
ndppp_apply_delay.control.type                              = dppp
ndppp_apply_delay.control.inplace                           = True
ndppp_apply_delay.control.max_per_node                      = {{ num_proc_per_node_limit }}
ndppp_apply_delay.control.error_tolerance                   = {{ error_tolerance }}
ndppp_apply_delay.control.mapfiles_in                       = [dpppconcat.output.mapfile,expand_h5_map.output.mapfile]
ndppp_apply_delay.control.inputkeys                         = [inputms,h5parm]
ndppp_apply_delay.argument.numthreads                       = {{ max_dppp_threads }}
ndppp_apply_delay.argument.msin                             = inputms
ndppp_apply_delay.argument.msin.datacolumn                  = {{ delaycal_col }}
ndppp_apply_delay.argument.msin.baseline                    = *&
ndppp_apply_delay.argument.msout.datacolumn                 = CORRECTED_DATA
ndppp_apply_delay.argument.msout.storagemanager		    = dysco
ndppp_apply_delay.argument.msout.writefullresflag           = False
ndppp_apply_delay.argument.steps                            = [applyphase,applyamp,count]
ndppp_apply_delay.argument.applyphase.type                  = applycal
ndppp_apply_delay.argument.applyphase.parmdb                = h5parm
ndppp_apply_delay.argument.applyphase.correction            = phase000
ndppp_apply_delay.argument.applyphase.solset                = sol000
ndppp_apply_delay.argument.applyphase.updateweights         = false
ndppp_apply_delay.argument.applyamp.type            	    = applycal
ndppp_apply_delay.argument.applyamp.parmdb          	    = h5parm
ndppp_apply_delay.argument.applyamp.correction      	    = amplitude000
ndppp_apply_delay.argument.applyamp.solset          	    = sol000
ndppp_apply_delay.argument.applyamp.updateweights   	    = false

############################################
#                                         ##
#                  CLEANUP                ##
#                                         ##
############################################

# delete ndppp_prep_target files
delete_prep_target.control.kind		   = recipe
delete_prep_target.control.type		   = executable_args
delete_prep_target.control.executable	   = /bin/rm
delete_prep_target.control.mapfile_in	   = ndppp_prep_target.output.mapfile
delete_prep_target.control.inputkey	   = msin
delete_prep_target.control.arguments	   = [-r,msin]

# delete intermediate files for delay calibrator
delete_phaseup.control.kind            = recipe
delete_phaseup.control.type            = executable_args
delete_phaseup.control.executable      = /bin/rm
delete_phaseup.control.mapfile_in      = dppp_phaseup.output.mapfile
delete_phaseup.control.inputkey        = msin
delete_phaseup.control.arguments       = [-r,msin]

# compress mapfiles for plotting
make_results_compress.control.kind                             =   plugin
make_results_compress.control.type                             =   compressMapfile
make_results_compress.control.mapfile_in                       =   dpppconcat.output.mapfile
make_results_compress.control.mapfile_dir                      =   input.output.mapfile_dir
make_results_compress.control.filename                         =   make_results_compress.mapfile

# set the pointing direction
make_summary.control.type                                      =   pythonplugin
make_summary.control.executable                                =   {{ scripts }}/make_summaryVLBI.py
make_summary.control.error_tolerance                           =   {{ error_tolerance }}
make_summary.control.mapfile_in                                =   make_results_compress.output.mapfile
make_summary.control.inputkey                                  =   infiles
make_summary.argument.observation_directory                    =   {{ working_directory }}
make_summary.argument.logfile                                  =   {{ log_file }}
make_summary.argument.h5parmdb                                 =   expand_h5_map.output.mapfile
# make_summary.argument.inspection_directory                     =   {{ inspection_directory }}
make_summary.argument.MSfile                                   =   infiles


##################################################################
#                                                               ##
#                   END OF PIPELINE                             ##
#                                                               ##
##################################################################
